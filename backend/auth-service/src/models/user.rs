use diesel::prelude::*;
use uuid::Uuid;

use crate::utils::password::{hash_password, verify_password};

/// Represents a user in the database
///
/// This struct maps to the users table and contains user account information
///
/// # Fields
/// * `id` - Unique identifier for the user
/// * `username` - User's chosen username
/// * `password` - Hashed password string (optional for passkey-only accounts)
/// * `email` - User's email address
/// * `is_verified` - Email verification status
/// * `is_active` - Account active status
#[derive(Queryable, Selectable, Clone)]
#[diesel(table_name = crate::schema::users)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct User {
    id: Uuid,
    username: String,
    password: Option<String>,
    email: String,
    is_verified: bool,
    is_active: bool,
}

impl User {
    /// Returns the user's unique identifier
    pub fn get_uuid(&self) -> Uuid {
        self.id
    }

    /// Returns the user's username
    pub fn get_username(&self) -> String {
        self.username.clone()
    }

    /// Returns the user's email address
    pub fn get_email(&self) -> String {
        self.email.clone()
    }

    /// Checks if the user has a password set
    ///
    /// # Returns
    /// * `true` if the user has a password
    /// * `false` if the user is passkey-only
    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    /// Validates if the provided password matches the stored hash
    ///
    /// # Arguments
    /// * `password` - The plain text password to verify
    ///
    /// # Returns
    /// * `true` if the password matches
    /// * `false` if the password is invalid or user has no password
    pub fn is_password_valid(&self, password: &str) -> bool {
        match &self.password {
            Some(hash) => verify_password(password, hash).is_ok(),
            None => false,
        }
    }

    /// Checks if the account email has been verified
    ///
    /// # Returns
    /// * `true` if the email is verified
    /// * `false` if the email is NOT verified
    pub fn is_account_verified(&self) -> bool {
        self.is_verified
    }

    /// Checks if the account has been deleted temporarily
    ///
    /// # Returns
    /// * `true` if the account has been deleted temporarily
    /// * `false` if the account has been NOT deleted temporarily
    pub fn is_account_active(&self) -> bool {
        self.is_active
    }
}

/// Represents a new user to be inserted into the database
///
/// This struct is used for creating new user accounts
///
/// # Fields
/// * `id` - Given UUID for the new account
/// * `username` - Chosen username for the new account
/// * `password` - Password that will be hashed before storage (optional for passkey-only)
/// * `email` - Email address for the account
#[derive(Insertable)]
#[diesel(table_name = crate::schema::users)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct NewUser {
    id: Uuid,
    username: String,
    password: Option<String>,
    email: String,
}

impl NewUser {
    /// Creates a new user account with password
    ///
    /// # Arguments
    /// * `username` - Chosen username
    /// * `password` - Plain text password that will be hashed
    /// * `email` - Email address
    ///
    /// # Returns
    /// * `Ok(NewUser)` - A new `NewUser` instance ready for database insertion
    /// * `Err(())` - If the `NewUser` could not be created
    pub fn new(username: &str, password: &str, email: &str) -> Result<Self, ()> {
        let hash = hash_password(password)?;

        Ok(Self {
            id: Uuid::new_v4(),
            username: username.to_string(),
            password: Some(hash),
            email: email.to_string(),
        })
    }

    /// Creates a new passkey-only user account (no password)
    ///
    /// # Arguments
    /// * `username` - Chosen username
    /// * `email` - Email address
    ///
    /// # Returns
    /// * A new `NewUser` instance ready for database insertion
    pub fn new_passkey_only(username: &str, email: &str) -> Self {
        Self {
            id: Uuid::new_v4(),
            username: username.to_string(),
            password: None,
            email: email.to_string(),
        }
    }

    /// Get the UUID created by the backend
    ///
    /// # Returns
    /// * `UUID` - The UUID generated by the backend
    pub fn get_uuid(&self) -> Uuid {
        self.id
    }
}
